{"version":3,"file":"js/486.946392d7.js","mappings":"+LACUA,MAAA,mF,GAKGA,MAAA,8F,GAIIA,MAAA,gF,sHATbC,EAAAA,EAAAA,IAmBO,OAnBPC,EAmBO,cAlBHC,EAAAA,EAAAA,IAEM,OAFDH,MAAA,6HAAqH,EACtHG,EAAAA,EAAAA,IAAoB,YAAd,aAAO,iBAEjBA,EAAAA,EAAAA,IAA0F,OAArFH,MAAA,iFAA8E,WACnFG,EAAAA,EAAAA,IAaM,MAbNC,EAaM,cAZFD,EAAAA,EAAAA,IAEM,OAFDE,GAAG,YACJL,MAAA,yG,WAEJG,EAAAA,EAAAA,IAQM,MARNG,EAQM,EAPFC,EAAAA,EAAAA,IAEqCC,EAAA,CAF3BC,QAAQ,WAXlCC,WAWsDC,EAAAC,UAXtD,sBAAAC,EAAA,KAAAA,EAAA,GAAAC,GAWsDH,EAAAC,UAASE,GAAEC,MAAM,OAAOC,QAAQ,UACjEhB,MAAA,sBACAiB,MAAO,CAAC,a,wBACbV,EAAAA,EAAAA,IACwDW,EAAA,CAfxER,WAcuCC,EAAAQ,eAdvC,sBAAAN,EAAA,KAAAA,EAAA,GAAAC,GAcuCH,EAAAQ,eAAcL,GAAEd,MAAA,sBAA0B,iBAAYe,MAAM,SAC/EN,QAAQ,WAAWO,QAAQ,W,wBAC/BT,EAAAA,EAAAA,IAAmGa,EAAA,CAA3FC,QAAOC,EAAAC,iBAAkBvB,MAAA,mCAAsCS,QAAQ,S,CAhB/Fe,SAAAC,EAAAA,EAAAA,KAgBuG,IAAIZ,EAAA,KAAAA,EAAA,KAhB3Ga,EAAAA,EAAAA,IAgBuG,YAhBvGC,EAAA,G,gBAiBgBpB,EAAAA,EAAAA,IAAuGa,EAAA,CAA/FC,QAAOC,EAAAM,oBAAqB5B,MAAA,mCAAuCS,QAAQ,S,CAjBnGe,SAAAC,EAAAA,EAAAA,KAiB2G,IAAIZ,EAAA,KAAAA,EAAA,KAjB/Ga,EAAAA,EAAAA,IAiB2G,YAjB3GC,EAAA,G,2CCoBO,MAAME,EACTC,WAAAA,CAAYC,GACRC,KAAKD,UAAUA,EACfC,KAAKC,KAAK,KACVD,KAAKE,UAAU,CACnB,CACAC,aAAAA,CAAcC,GAEV,GADAA,EAAK/B,GAAK2B,KAAKK,eACXD,EAAKE,UAAYF,EAAKE,SAASC,OAAS,EACxC,IAAK,IAAIC,EAAI,EAAGA,EAAIJ,EAAKE,SAASC,OAAQC,IACtCR,KAAKG,cAAcC,EAAKE,SAASE,GAG7C,CACAH,YAAAA,GAEI,OADAL,KAAKE,YACEO,OAAOT,KAAKE,UACvB,CAIA,UAAMQ,CAAKC,GAEP,GADAC,QAAQC,IAAIF,GACE,MAAXX,KAAKC,KACJD,KAAKC,KAAK,CACN5B,GAAG2B,KAAKK,eACRM,IAAIA,EACJG,IAAI,MACJC,KAAI,EACJT,SAAS,IAKbN,KAAKD,UAAUiB,MAAKC,EAAAA,EAAAA,GAAKjB,KAAKC,OAC9BD,KAAKD,UAAUmB,SACflB,KAAKD,UAAUoB,cACd,CACD,IAAIC,EAASpB,KAAKC,KAElB,MAAM,EAAK,CAMP,GAFAW,QAAQC,IAAI,UAAUO,EAAST,KAC/BC,QAAQC,IAAIF,GAAKS,EAAST,KACG,GAA1BS,EAASd,SAASC,OAAU,CACxBc,OAAOV,IAAMU,OAAOD,EAAST,MAC5BS,EAASd,SAASI,KAAK,CACnBrC,GAAG2B,KAAKK,eACRS,IAAI,OACJH,IAAIA,EACJI,KAAI,EACJT,SAAS,KAEbc,EAASd,SAASI,KAAK,CACnBrC,GAAG2B,KAAKK,eACRS,IAAI,QACJH,IAAI,KACJI,KAAI,EACJT,SAAS,OAGbc,EAASd,SAASI,KAAK,CACnBrC,GAAG2B,KAAKK,eACRM,IAAI,KACJG,IAAI,OACJC,KAAI,EACJT,SAAS,KAEbc,EAASd,SAASI,KAAK,CACnBrC,GAAG2B,KAAKK,eACRM,IAAIA,EACJG,IAAI,QACJC,KAAI,EACJT,SAAS,MAMjBN,KAAKD,UAAUuB,eAAe,EAC1BL,EAAAA,EAAAA,GAAKG,EAASd,SAAS,KACvBW,EAAAA,EAAAA,GAAKG,EAASd,SAAS,KACzBc,EAAS/C,IACX,KACJ,CAUI,GAAGgD,OAAOV,IAAMU,OAAOD,EAAST,OAAOS,EAASd,SAAS,GAAGS,IAAI,CAC5DK,EAASd,SAAS,GAAGK,IAAIA,EACzBS,EAASd,SAAS,GAAGS,KAAI,EAIzBf,KAAKD,UAAUwB,WAAWH,EAASd,SAAS,GAAGjC,IAAG4C,EAAAA,EAAAA,GAAKG,EAASd,SAAS,KACzE,KACJ,CAAM,GAAGe,OAAOV,GAAKU,OAAOD,EAAST,OAAOS,EAASd,SAAS,GAAGS,IAAI,CACjEK,EAASd,SAAS,GAAGK,IAAIA,EACzBS,EAASd,SAAS,GAAGS,KAAI,EAIzBf,KAAKD,UAAUwB,WAAWH,EAASd,SAAS,GAAGjC,IAAG4C,EAAAA,EAAAA,GAAKG,EAASd,SAAS,KACzE,KACJ,CAASe,OAAOV,IAAMU,OAAOD,EAAST,KAClCS,EAASA,EAASd,SAAS,GACtBe,OAAOV,GAAKU,OAAOD,EAAST,OACjCS,EAASA,EAASd,SAAS,GAGvC,CACJ,CAKAN,KAAKD,UAAUoB,QAAQ,GAC3B,CAIA,aAAMK,GAIF,IAAIC,GAAMC,EAAAA,EAAAA,IAAa1B,KAAKC,MAExB0B,GAAQC,EAAAA,EAAAA,IAAY5B,KAAKC,KAAKwB,GAE9BI,GAAUC,EAAAA,EAAAA,IAAc9B,KAAKC,KAAKwB,GAItC,GAAGA,GAAOzB,KAAKC,KAAK5B,GAIc,GAA3B2B,KAAKC,KAAKK,SAASC,QAClBP,KAAKC,KAAK,KACVD,KAAKD,UAAUgC,UACf/B,KAAKD,WAAUiC,EAAAA,EAAAA,QAMfhC,KAAKC,MAAKgB,EAAAA,EAAAA,GAAKjB,KAAKC,KAAKK,SAAS,IAClCN,KAAKD,UAAUgC,UACf/B,KAAKD,WAAUiC,EAAAA,EAAAA,MACfhC,KAAKD,UAAUiB,MAAKC,EAAAA,EAAAA,GAAKjB,KAAKC,OAC9BD,KAAKD,UAAUmB,SACflB,KAAKD,UAAUoB,QAAQ,UAgB3B,GAA4B,GAAzBQ,EAAQrB,SAASC,OAIhB,GAA8B,GAA3BsB,EAAUvB,SAAS,GAAGS,KACrBkB,EAAAA,EAAAA,IAAmBjC,KAAKC,KAAKwB,GAAOnB,SAAS,GAC7CN,KAAKD,UAAUuB,eAAe,GAAGO,EAAUxD,QAC1C,CACD,IAAI6D,EAAQ,CACR7D,GAAG2B,KAAKK,eACRS,IAAI,OACJH,IAAI,KACJI,KAAI,EACJT,SAAS,KAEb2B,EAAAA,EAAAA,IAAmBjC,KAAKC,KAAKwB,GAAOnB,SAAS,EACzCW,EAAAA,EAAAA,GAAKiB,IACLjB,EAAAA,EAAAA,GAAKY,EAAUvB,SAAS,KAE5BN,KAAKD,UAAUuB,eAAe,EAC1BL,EAAAA,EAAAA,GAAKiB,IACLjB,EAAAA,EAAAA,GAAKY,EAAUvB,SAAS,KAC1BuB,EAAUxD,GAChB,KAKA,CAMAuC,QAAQC,IAAIb,KAAKC,MACjB,IAAIkC,GAASlB,EAAAA,EAAAA,GAAKU,EAAQrB,SAAS,IACnC6B,EAASrB,IAAI,OACbd,KAAKG,cAAcgC,IAMnBF,EAAAA,EAAAA,IAAmBjC,KAAKC,KAAKwB,GAAOnB,SAAS,EACzCW,EAAAA,EAAAA,GAAKkB,IACLlB,EAAAA,EAAAA,GAAKY,EAAUvB,SAAS,KAE5BM,QAAQC,IAAIb,KAAKC,MACjBD,KAAKD,UAAUuB,eAAe,EAC1BL,EAAAA,EAAAA,GAAKkB,IACLlB,EAAAA,EAAAA,GAAKY,EAAUvB,SAAS,KAC1BuB,EAAUxD,IACZuC,QAAQC,IAAIb,KAAKD,UAAUqC,aAAapC,KAAKC,KAAK5B,KAClD2B,KAAKD,UAAUwB,WAAWI,EAAQtD,IAAG4C,EAAAA,EAAAA,GAAKU,EAAQrB,SAAS,IAC/D,CAER,EDjOJ,OACI+B,KAAM,YACNC,KAAAA,GAEA,EACAtB,IAAAA,GACI,MAAO,CAMHuB,KAAK,KACL3D,UAAU,KAIVsB,UAAU,EAMVsC,UAAU,CAAC,EAIXC,OAAO,GACPC,YAAY,GAIZvD,eAAe,KACf6B,KAAK,CACL,EAER,EACA2B,QAAQ,CAIJpD,gBAAAA,GACI,GAAmB,MAAhBS,KAAKpB,UAEJ,YADAgE,OAAOC,MAAM,UAGjB,MAAMlC,EAAIX,KAAKb,eACfa,KAAKb,eAAe,IAChB2D,EAAAA,EAAAA,IAAgBnC,GAIpBX,KAAKuC,KAAK7B,KAAKD,OAAOE,IAHlBiC,OAAOC,MAAM,cAIrB,EACAjD,mBAAAA,GACuB,MAAhBI,KAAKpB,UAIW,MAAhBoB,KAAKuC,KAAKtC,KAIbD,KAAKuC,KAAKf,UAHNoB,OAAOC,MAAM,QAJbD,OAAOC,MAAM,SAQrB,GAEJE,OAAAA,GACI/C,KAAKuC,KAAK,IAAI1C,GAASmC,EAAAA,EAAAA,MAC3B,G,UEvFJ,MAAMgB,GAA2B,OAAgB,EAAQ,CAAC,CAAC,SAAS9B,KAEpE,O","sources":["webpack://tree-visualize/./src/pages/TreePage.vue","webpack://tree-visualize/./src/algorithm/SortTree.js","webpack://tree-visualize/./src/pages/TreePage.vue?548e"],"sourcesContent":["<template>\n    <main style=\"display: flex;flex-direction: column;min-width: 1500px;overflow: scroll;\">\n        <div style=\"display: flex;font-size: 20px;color: #4a4a4a;font-weight: bold;padding: 10px;width: 100%;flex-direction: row;\">\n            <span>树形结构可视化</span>\n        </div>\n        <div style=\"height: 2px;background-color: #8a8a8a;margin-bottom: 20px;width: 100%;\"></div>\n        <div style=\"display: flex;flex-direction: row-reverse;overflow:scroll;justify-content: center;\">\n            <div id=\"mountNode\"\n                style=\"border-radius: 10px;border: 2px #8a8a8a solid;width: 1200px; height: 800px;margin-right: 20px;\">\n            </div>\n            <div style=\"display: flex;flex-direction: column;margin-right: 20px;width: 200px;\">\n                <v-select variant=\"outlined\" v-model=\"algorithm\" label=\"选择算法\" density=\"compact\" \n                     style=\"max-height: 60px;\"\n                    :items=\"['二叉排序树的构建']\"></v-select>\n                <v-text-field v-model=\"nodeValueToAdd\" style=\"max-height: 60px;\" single-line label=\"输入节点权值\"\n                    variant=\"outlined\" density=\"compact\"></v-text-field>\n                <v-btn @click=\"handleAddClicked\" style=\"max-height: 60px;margin: 5px;\" variant=\"tonal\">插入节点</v-btn>\n                <v-btn @click=\"handleDeleteClicked\" style=\"max-height: 60px; margin: 5px;\" variant=\"tonal\">删除节点</v-btn>\n            </div>\n        </div>\n    </main>\n</template>\n\n<script>\nimport { getTreeGraph, isNumericString } from '@/utils/tree_funcs';\nimport { SortTree } from '@/algorithm/SortTree';\nexport default {\n    name: 'TreeGraph',\n    setup(){\n\n    },\n    data(){\n        return {\n            /**\n             * 一个算法类\n             * 传入图对象，对图的操作再算法中实现\n             * 提供算法的操作接口\n             */\n            tree:null,\n            algorithm:null,\n            /**\n             * id迭代\n             */\n            idCounter:0,\n            /**\n             * 因为id必须保持唯一\n             * 所以这里设置一个字典，用于查询id节点对应的val\n             * 其中id自动迭代，val为用户输入\n             */\n            valIdDict:{},\n            /** \n             * 已经添加的节点\n             */\n            addIds:[],\n            nodeIdAdded:[],\n            /**\n             * 绑定待添加的节点输入\n             */\n            nodeValueToAdd:null,\n            data:{\n            },\n        }\n    },\n    methods:{\n        /**\n         * 监听添加按钮\n         */\n        handleAddClicked(){\n            if(this.algorithm==null){\n                window.alert(\"选择一个算法\")\n                return;\n            }\n            const val=this.nodeValueToAdd;\n            this.nodeValueToAdd=\"\";\n            if(!isNumericString(val)){\n                window.alert(\"输入节点格式必须是数字\")\n                return;\n            }\n            this.tree.push(String(val));\n        },\n        handleDeleteClicked(){\n            if(this.algorithm==null){\n                window.alert(\"选择一个算法\")\n                return;\n            }\n            if(this.tree.root==null){\n                window.alert(\"没有数据\")\n                return;\n            }\n            this.tree.pop_min();\n        },\n    },\n    mounted() {\n        this.tree=new SortTree(getTreeGraph());\n    },\n};\n</script>\n\n<style>\n/* Hide scrollbar and make the container fill the parent */\n#mountNode {\n    overflow: hidden;\n    margin: 0;\n}\n</style>","//import { delay } from \"@/utils/funcs\";\n\nimport { copy, getFatherById, getFatherByIdRefer, getMinNodeId, getNodeById, getTreeGraph } from \"@/utils/tree_funcs\";\n\n//import { convertNode } from \"@/utils/funcs\";\n\n/**\n * 需要传入对应的图对象，将操作直接内嵌到算法 \n * 更新视图方法我试了三种\n * 1. removeChild+addChild 动画很全，缺点是不符合实际算法逻辑，而且需要每次操作delay等待动画播放(更新视图的时候每次更新都等待一段时间无奈之举,也不知道为什么开启动画后会出现布局BUG,每次操作等待一段时间可以解决这个BUG(推测更新视图不能同时进行两个操作，与内部实现逻辑有关？))\n * 2. updateChildren 需要单独调用重新渲染\n * 3. 获取节点操作节点updateItem 符合逻辑，动画有的没有\n * \n * 另外使用updateChildren的时候要注意\n * 如果对一个节点father的子树做更新，并且需要应用到布局，就要更新这个子树所有节点的id(我使用调用uodataNodeIds实现更新)\n * 如果说father的节点数据没有改变，可以不更新id\n * \n * 还有就是区分引用和copy\n * 我是调用库中的函数时都传入一个深拷贝防止出现问题\n */\nexport class SortTree{\n    constructor(treeGraph){\n        this.treeGraph=treeGraph;\n        this.root=null;\n        this.idCounter=0;\n    }\n    updateNodeIds(node) {\n        node.id = this.getIdCounter();\n        if (node.children && node.children.length > 0) {\n            for (let i = 0; i < node.children.length; i++) {\n                this.updateNodeIds(node.children[i]);\n            }\n        }\n    }\n    getIdCounter(){\n        this.idCounter++;\n        return String(this.idCounter);\n    }\n    /**\n     * 传入的node为@/algorithm/Node.js中的类\n     */\n    async push(val){\n        console.log(val)\n        if(this.root==null){\n            this.root={\n                id:this.getIdCounter(),\n                val:val,\n                pos:\"mid\",\n                vis:true,\n                children:[]\n            };\n            /**\n             * 根节点的添加需要首先装配数据\n             */\n            this.treeGraph.data(copy(this.root));\n            this.treeGraph.render();\n            this.treeGraph.fitView();\n        }else{\n            var node_now=this.root;\n            // eslint-disable-next-line\n            while(true){\n                /**\n                 * 没有孩子，添加两个节点，一个隐式的  \n                 */\n                console.log(\"父节点的VAL\",node_now.val);\n                console.log(val<=node_now.val);\n                if(node_now.children.length==0){\n                    if(Number(val)<=Number(node_now.val)){//左子树\n                        node_now.children.push({\n                            id:this.getIdCounter(),\n                            pos:\"left\",\n                            val:val,\n                            vis:true,\n                            children:[]\n                        })\n                        node_now.children.push({\n                            id:this.getIdCounter(),\n                            pos:\"right\",\n                            val:null,\n                            vis:false,\n                            children:[]\n                        })\n                    }else{\n                        node_now.children.push({\n                            id:this.getIdCounter(),\n                            val:null,\n                            pos:\"left\",\n                            vis:false,\n                            children:[]\n                        })\n                        node_now.children.push({\n                            id:this.getIdCounter(),\n                            val:val,\n                            pos:\"right\",\n                            vis:true,\n                            children:[]\n                        })\n                    }\n                    /**\n                     * 更新绘图数据  \n                     */\n                    this.treeGraph.updateChildren([\n                        copy(node_now.children[0]),\n                        copy(node_now.children[1])\n                    ],node_now.id);\n                    break;\n                }\n                /**\n                 * 有孩子\n                 * 因为我们已经保证了有孩子的一定有两个孩子(可能有一个不显示)\n                 * 所以这里需要先获取当前节点应该往哪插/或者进入下一层\n                 * 插入到这一层只有两种情况 \n                 * 1. 左节点为不可见且val比父节点小(或等)\n                 * 2. 右节点为不可见状态且比父节点大  \n                 */\n                else{\n                    if(Number(val)<=Number(node_now.val)&&!node_now.children[0].vis){\n                        node_now.children[0].val=val;\n                        node_now.children[0].vis=true;\n                        /**\n                         * 这里调用更新\n                         */\n                        this.treeGraph.updateItem(node_now.children[0].id,copy(node_now.children[0]))\n                        break;\n                    }else if(Number(val)>Number(node_now.val)&&!node_now.children[1].vis){\n                        node_now.children[1].val=val;\n                        node_now.children[1].vis=true;\n                        /**\n                         * 这里调用更新\n                         */\n                        this.treeGraph.updateItem(node_now.children[1].id,copy(node_now.children[1]))\n                        break;\n                    }else if(Number(val)<=Number(node_now.val)){\n                        node_now=node_now.children[0];\n                    }else if(Number(val)>Number(node_now.val)){\n                        node_now=node_now.children[1];\n                    }\n                }\n            }\n        }\n        /**\n         * 调整视图\n         * 根据当前图的结构缩放和移动视图\n         */\n        this.treeGraph.fitView(50)\n    }\n    /**\n     * 弹出最小的\n     */\n    async pop_min(){\n        /**\n         * 首先获取最小的节点的id\n         */\n        var minId=getMinNodeId(this.root);\n        // eslint-disable-next-line\n        var minNode=getNodeById(this.root,minId);\n        // eslint-disable-next-line\n        var minFather=getFatherById(this.root,minId);\n        /**\n         * 如果是根节点\n         */\n        if(minId==this.root.id){\n            /**\n             * 如果没有子节点\n             */\n            if(this.root.children.length==0){\n                this.root=null;\n                this.treeGraph.destroy();\n                this.treeGraph=getTreeGraph();\n            }\n            /**\n             * 有子节点，一定是右子节点\n             */\n            else{\n                this.root=copy(this.root.children[1]);\n                this.treeGraph.destroy();\n                this.treeGraph=getTreeGraph();\n                this.treeGraph.data(copy(this.root));\n                this.treeGraph.render();\n                this.treeGraph.fitView(50);\n            }\n        }\n        /**\n         * 其他节点\n         * 则有两种情况\n         * 1.节点没有右子节点\n         * 2.节点有右子节点\n         */\n        else{\n            /**\n             * 没有右子节点\n             * 更新父节点  \n             *   如果父节点含有右子节点，则更新为[新节点，右子节点]\n             *   反之，更新为[]\n             */\n            if(minNode.children.length==0){\n                /**\n                 * 更新父节点\n                 */\n                if(minFather.children[1].vis==false){\n                    getFatherByIdRefer(this.root,minId).children=[];\n                    this.treeGraph.updateChildren([],minFather.id);\n                }else{\n                    var newNode={\n                        id:this.getIdCounter(),\n                        pos:\"left\",\n                        val:null,\n                        vis:false,\n                        children:[]\n                    }\n                    getFatherByIdRefer(this.root,minId).children=[\n                        copy(newNode),\n                        copy(minFather.children[1])\n                    ];\n                    this.treeGraph.updateChildren([\n                        copy(newNode),\n                        copy(minFather.children[1])\n                    ],minFather.id);\n                }\n            }\n            /**\n             * 有右子节点\n             */\n            else{\n                /**\n                 * 更新父节点\n                 * 只需要更新夫节点的children为[minNode的右子节点,父节点的右子节点]\n                 * 不需要关注夫节点的右子节点的可见性\n                 */\n                console.log(this.root)\n                var leftNode=copy(minNode.children[1]);\n                leftNode.pos=\"left\";\n                this.updateNodeIds(leftNode);\n                /**\n                 * 这里值所以采用新的id是因为\n                 * 不采用新的他不渲染\n                 * 而且是子树全部都要更新\n                 */\n                getFatherByIdRefer(this.root,minId).children=[\n                    copy(leftNode),\n                    copy(minFather.children[1])\n                ];\n                console.log(this.root);\n                this.treeGraph.updateChildren([\n                    copy(leftNode),\n                    copy(minFather.children[1])\n                ],minFather.id);\n                console.log(this.treeGraph.findDataById(this.root.id));\n                this.treeGraph.updateItem(minNode.id,copy(minNode.children[1]))\n            }\n        }\n    }\n}","import { render } from \"./TreePage.vue?vue&type=template&id=8f4a27b6\"\nimport script from \"./TreePage.vue?vue&type=script&lang=js\"\nexport * from \"./TreePage.vue?vue&type=script&lang=js\"\n\nimport \"./TreePage.vue?vue&type=style&index=0&id=8f4a27b6&lang=css\"\n\nimport exportComponent from \"../../node_modules/vue-loader/dist/exportHelper.js\"\nconst __exports__ = /*#__PURE__*/exportComponent(script, [['render',render]])\n\nexport default __exports__"],"names":["style","_createElementBlock","_hoisted_1","_createElementVNode","_hoisted_2","id","_hoisted_3","_createVNode","_component_v_select","variant","modelValue","$data","algorithm","_cache","$event","label","density","items","_component_v_text_field","nodeValueToAdd","_component_v_btn","onClick","$options","handleAddClicked","default","_withCtx","_createTextVNode","_","handleDeleteClicked","SortTree","constructor","treeGraph","this","root","idCounter","updateNodeIds","node","getIdCounter","children","length","i","String","push","val","console","log","pos","vis","data","copy","render","fitView","node_now","Number","updateChildren","updateItem","pop_min","minId","getMinNodeId","minNode","getNodeById","minFather","getFatherById","destroy","getTreeGraph","getFatherByIdRefer","newNode","leftNode","findDataById","name","setup","tree","valIdDict","addIds","nodeIdAdded","methods","window","alert","isNumericString","mounted","__exports__"],"sourceRoot":""}